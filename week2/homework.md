Week2 HomeWork
============
### 1. 请你用自己的语言向我介绍 Java 运行时数据区（内存区域）

- **堆**: jvm里面最大一块内存，是各个线程共享的运行时内存区域，也是提供所有类实例和数组对象分配的区域。
它被划为新生代和老年代。同时也是GC收集垃圾的主要区域 （minor gc and full gc）.
jvm调优时，通过-Xms 指定初始化堆内存，-Xmx 指定最大堆内存
-----
- **虚拟机栈**: 每一个线程都有自己的虚拟机栈，用于存储栈帧。栈帧存了局部变量表，操作数栈，方法返回地址等信息。
虚拟机栈与它的线程同时被创建。jvm调优时，通过-Xss 指定栈的大小。如果线程请求分配的栈大小超过指定值则抛出StackOverFlow
, 如果在创建线程时，没有足够的内存创建对应的虚拟机栈，则抛出OOM
-----
- **本地方法栈**: 和虚拟机栈类似，与调用native方法的线程同时被创建。用于支持native方法的执行
-----
- **方法区（永久代、元空间）**: 是堆的一部分。方法区也是各个线程运行时共享的内存区域，在虚拟机启动时被创建。
静态变量，常量，类信息（构造方法/接口定义），运行时常量池都放在方法区中。<=jdk7,方法区的实现
是永久代（jvm进程所使用的内存区域），使用-XX:PermSize设置初始空间，-XX:MaxPermSize设置最大可分配空间；>=jdk8, 方法区的实现是元空间（物理内存区域）
，使用-XX:MetaspaceSize设置初始空间大小，-XX:MaxMetaspaceSize设置最大可分配空间大小。方法区的内存空间不足时，会抛出OOM
-----
- **运行时常量池（字符串常量池）**: jvm运行起来的常量池，每一个class对象都有一个运行时常量池，保存的是符号引用和字面量。字面量包含了数值和双引号引起的字符串值。
其中双引号引起的字符串值就保存在字符串常量池中，全局只有一个，所有类共享。StringTable类似于HashTable,保存了字符串对象的引用。
<=jdk6, 字符串常量池在运行时常量池中（属于永久代）；>=jdk7, 字符串常量池在堆中。
-----
- **直接内存**: 不是java虚拟机的内存区域，属于堆外内存。所以不受java堆大小限制。直接内存与堆内存相比，申请更耗费时间，但读写速度更快。
-----
- **为什么堆内存要分年轻代和老年代？**: 加快垃圾回收的时间，让内存使用更有效的被利用。大多对象都是朝生夕灭的，难以熬过一次minor gc，所以一开始都将他们放在新生代。
能熬过多次minor gc的对象通常难以被消灭，所以将它们移到老年代，用较低频率的full gc将他们标记回收
-----

### 2. 描述一个 Java 对象的生命周期
- **解释一个对象的创建过程**: 
    - 去常量池中定位到这个类的符号引用，检查是否该类是否被加载，如果没有，则加载此类
    - 为该对象分配内存空间
      - 指针碰撞: 内存地址连续 （新生代）
      - 空闲列表: 内存地址不连续 （老年代）
    - 内存空间初始化为默认值
    - 为该对象设置必要信息（哈希码，gc分代年龄等），保存在对象头
    - 执行init方法
-----
- **解释一个对象的内存分配**: 
    - 检查Eden是否放得下
      - 放得下，在年轻代分配对象内存
      - 放不下，进行minor gc
    - minor gc后，Eden是否放得下
      - 放得下，在年轻代分配对象内存
      - 放不下，去老年代看看
    - 老年代是否放得下
      - 放得下，在老年代分配对象内存
      - 放不下，进行full gc
    - full gc后，老年代是否放得下
      - 放得下，在老年代分配对象内存
      - 放不下，throw OOM
-----
- **解释一个对象的销毁过程**: 
  - 在gc回收时，与GC Root 没有任何引用链
  - 第一次标记
  - 执行对象Finalize()方法
  - 在gc回收时，任然没有与GC Root 没有任何引用链
  - 第二次标记
  - 销毁对象
-----
- **对象的 2 种访问方式是什么**:
  - 句柄访问: 本地变量表 &rarr; 对象实例数据指针（句柄池）&rarr; 对象实例数据
  - 直接指针访问: 本地变量表 &rarr;  对象实例数据
-----
- **为什么需要内存担保**: 年轻代无法分配内存，需要将年轻代的老对象放入老年代中，释放足够内存来分配给新对象
-----

### 3. 垃圾收集算法有哪些？垃圾收集器有哪些？他们的特点是什么？

- **收集算法**: 标记清除,拷贝,标记整理
-----
- **ParNew 收集器**: -XX:+UseParNewGC. 多线程去收集垃圾，Serial并行版本。新生代并行收集器（复制算法）
-----
- **ParallelScavenge 收集器**: -XX:+UseParallelGC,新生代使用并行回收器（复制算法）
。是吞吐量优先的收集器，吞吐量=（运行用户代码时间）/（运行用户代码时间+垃圾收集时间）。
-----
- **ParallelOld 收集器**: -XX:+UseParallelOldGC。 PS的老年代版本，老年代使用并行收集器（标记整理）。
也是是吞吐量优先收集器。
-----
- **CMS 收集器**: -XX:+UseConcMarkSweepGC.老年代并行收集器（标记清除）。堆使用到达阈值就会进行垃圾收集。
低延时，减少stw对用户代码运行的影响。具体收集步骤：
  - stw, 初始标记，标记处GC Roots关联到的对象
  - no stw, 并发标记，遍历GC Roots关联的对象的引用链进行标记
  - stw, 重新标记，修正并发标记期间产生的新对象并标记
  - no stw, 并发清楚垃圾
-----
- **G1 收集器**: -XX:+UseG1GC. 面向服务端应用的全功能型垃圾收集器。低延时（与CMS相似），吞吐量（在回收阶段，按回收成本进行排序，从而控制回收时间）都行的整堆垃圾收集器。
G1的内存划分采用若干固定大小的Region（E/S/H/老年代）。全局采用标记整理算法，局部采用复制算法



